'use strict';

var atom$1 = require('atom');
var eventKit = require('event-kit');
var store$1 = require('svelte/store');
var internal = require('svelte/internal');
var svelte = require('svelte');

class ConsoleManager {
  constructor(view) {
    this.view = view;
    this.emitter = new eventKit.Emitter();
  }

  destroy() {
    this.emitter.dispose();
  } // Toggle console panel


  hide() {
    this.view.hide();
  }

  show() {
    this.view.show();
  }

  toggle() {
    this.view.toggle();
  }

  stickBottom() {
    this.view.stickTop = false;
  }

  stickTop() {
    this.view.stickTop = true;
  } // Log message with default level


  log(message, level = 'log') {
    this.view.log(message, level);
  } // Log error


  error(message) {
    this.log(message, 'error');
  } // Log warning


  warn(message) {
    this.log(message, 'warning');
  } // Log notice


  info(message) {
    this.log(message, 'info');
  } // Log debug message


  debug(message) {
    this.log(message, 'debug');
  } // Log raw text


  raw(rawText, level = 'raw', lineEnding = '\n') {
    console.log('Raw output', rawText); // rawText.split(lineEnding).map(line => {

    this.log(String(true), level); // });
  } // Clear console panel


  clear() {
    this.view.clear();
  }

}

var store = store$1.writable({
  lines: [],
  showTimestamp: true,
  clear: false,
  filters: []
});

function getConfig(key = '') {
  const packageName = 'console';
  return key ? atom.config.get(`${packageName}.${key}`) : atom.config.get(packageName);
}

function showDock() {
  const panelLocation = getConfig('panelLocation');

  switch (panelLocation.toLowerCase()) {
    case 'left':
      atom.workspace.getLeftDock().show();
      break;

    case 'right':
      atom.workspace.getRightDock().show();
      break;

    default:
      atom.workspace.getBottomDock().show();
      break;
  }
}

function hideDock() {
  const panelLocation = getConfig('panelLocation');

  switch (panelLocation.toLowerCase()) {
    case 'left':
      atom.workspace.getLeftDock().hide();
      break;

    case 'right':
      atom.workspace.getRightDock().hide();
      break;

    default:
      atom.workspace.getBottomDock().hide();
      break;
  }
}

function getTimestamp() {
  const date = new Date();
  const hh = `0${date.getHours()}`.slice(-2);
  const mm = `0${date.getMinutes()}`.slice(-2);
  const ss = `0${date.getSeconds()}`.slice(-2);
  const ms = `${date.getMilliseconds()}0`.slice(0, 3);
  return {
    visible: `${hh}:${mm}:${ss}.${ms}`,
    tooltip: date.toString()
  };
}

function mapLevel(level) {
  console.log('mapLevel', level);

  switch (level) {
    case 'debug':
      return {
        text: `debug`,
        icon: 'icon-bug'
      };

    case 'error':
      return {
        text: `error`,
        icon: 'icon-flame'
      };

    case 'info':
      return {
        text: `info`,
        icon: 'icon-info'
      };

    case 'warn':
    case 'warning':
      return {
        text: `warning`,
        icon: 'icon-issue-opened'
      };

    case 'raw':
      return {
        text: `info`,
        icon: 'icon-code'
      };

    default:
      {
        return {
          text: `highlight`,
          icon: 'icon-quote'
        };
      }
  }
}

function handleOverflow() {
  return getConfig('wordWrap') ? `
    overflow: hidden;
    white-space: pre-wrap;
  ` : '';
}

function initStatusBarHeight() {
  const statusBar = document.querySelector('status-bar');

  if (statusBar !== null && statusBar !== void 0 && statusBar.offsetHeight) {
    document.documentElement.style.setProperty('--status-bar-height', `${statusBar.offsetHeight}px`);
  }
}

/* src/views/console.svelte generated by Svelte v3.32.3 */

const { console: console_1 } = internal.globals;
const file = "src/views/console.svelte";

function add_css() {
	var style = internal.element("style");
	style.id = "svelte-n6w8gh-style";
	style.textContent = ".scrollable.svelte-n6w8gh.svelte-n6w8gh{height:100%;overflow:auto;width:100%}.panel-body.svelte-n6w8gh.svelte-n6w8gh{background-color:var(--inset-panel-background-color);cursor:text;height:100%}.console-lines.svelte-n6w8gh.svelte-n6w8gh{overflow:visible}.console-lines.svelte-n6w8gh.svelte-n6w8gh:empty{padding:0}p.svelte-n6w8gh.svelte-n6w8gh{display:flex;margin:0}p[hidden].svelte-n6w8gh.svelte-n6w8gh{display:none}p.svelte-n6w8gh .timestamp.svelte-n6w8gh{padding:5px 10px;user-select:none}p.svelte-n6w8gh .badge.svelte-n6w8gh{cursor:pointer;font-size:11px;position:sticky;top:5px}p.svelte-n6w8gh .message.svelte-n6w8gh{font-size:unset;flex-grow:1;margin-bottom:var(--status-bar-height)}p.svelte-n6w8gh .message.svelte-n6w8gh::selection{background-color:var(--background-color-selected);color:var(--text-color-selected)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uc29sZS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBMkh1QixXQUFBLDRCQUFBLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiY29uc29sZS5zdmVsdGUiXX0= */";
	internal.append_dev(document.head, style);
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i].level;
	child_ctx[11] = list[i].message;
	child_ctx[12] = list[i].timestamp;
	return child_ctx;
}

// (116:10) {:else}
function create_else_block(ctx) {
	let t_value = /*message*/ ctx[11] + "";
	let t;

	const block = {
		c: function create() {
			t = internal.text(t_value);
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*lines*/ 1 && t_value !== (t_value = /*message*/ ctx[11] + "")) internal.set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(t);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(116:10) {:else}",
		ctx
	});

	return block;
}

// (107:10) {#if typeof message === 'string'}
function create_if_block(ctx) {
	let t0;
	let pre;
	let t1_value = /*message*/ ctx[11] + "";
	let t1;
	let pre_style_value;
	let if_block = /*showTimestamp*/ ctx[3] && create_if_block_1(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			t0 = internal.space();
			pre = internal.element("pre");
			t1 = internal.text(t1_value);
			internal.attr_dev(pre, "class", "message svelte-n6w8gh");
			internal.attr_dev(pre, "style", pre_style_value = /*wordWrap*/ ctx[2] && handleOverflow());
			internal.add_location(pre, file, 114, 12, 2820);
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			internal.insert_dev(target, t0, anchor);
			internal.insert_dev(target, pre, anchor);
			internal.append_dev(pre, t1);
		},
		p: function update(ctx, dirty) {
			if (/*showTimestamp*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(t0.parentNode, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*lines*/ 1 && t1_value !== (t1_value = /*message*/ ctx[11] + "")) internal.set_data_dev(t1, t1_value);

			if (dirty & /*wordWrap*/ 4 && pre_style_value !== (pre_style_value = /*wordWrap*/ ctx[2] && handleOverflow())) {
				internal.attr_dev(pre, "style", pre_style_value);
			}
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) internal.detach_dev(t0);
			if (detaching) internal.detach_dev(pre);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(107:10) {#if typeof message === 'string'}",
		ctx
	});

	return block;
}

// (108:12) {#if showTimestamp}
function create_if_block_1(ctx) {
	let div_1;
	let pre;
	let span;
	let t_value = /*timestamp*/ ctx[12].visible + "";
	let t;
	let span_title_value;
	let pre_class_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div_1 = internal.element("div");
			pre = internal.element("pre");
			span = internal.element("span");
			t = internal.text(t_value);
			internal.attr_dev(span, "class", "text-highlight");
			internal.attr_dev(span, "title", span_title_value = /*timestamp*/ ctx[12].tooltip);
			internal.add_location(span, file, 110, 18, 2664);
			internal.attr_dev(pre, "class", pre_class_value = "badge " + /*coloredBadges*/ ctx[4] + "-" + mapLevel(/*level*/ ctx[10]).text + " icon " + mapLevel(/*level*/ ctx[10]).icon + " svelte-n6w8gh");
			internal.add_location(pre, file, 109, 16, 2536);
			internal.attr_dev(div_1, "class", "timestamp svelte-n6w8gh");
			internal.add_location(div_1, file, 108, 14, 2496);
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, div_1, anchor);
			internal.append_dev(div_1, pre);
			internal.append_dev(pre, span);
			internal.append_dev(span, t);

			if (!mounted) {
				dispose = internal.listen_dev(pre, "click", /*scrollToTop*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*lines*/ 1 && t_value !== (t_value = /*timestamp*/ ctx[12].visible + "")) internal.set_data_dev(t, t_value);

			if (dirty & /*lines*/ 1 && span_title_value !== (span_title_value = /*timestamp*/ ctx[12].tooltip)) {
				internal.attr_dev(span, "title", span_title_value);
			}

			if (dirty & /*coloredBadges, lines*/ 17 && pre_class_value !== (pre_class_value = "badge " + /*coloredBadges*/ ctx[4] + "-" + mapLevel(/*level*/ ctx[10]).text + " icon " + mapLevel(/*level*/ ctx[10]).icon + " svelte-n6w8gh")) {
				internal.attr_dev(pre, "class", pre_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(div_1);
			mounted = false;
			dispose();
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(108:12) {#if showTimestamp}",
		ctx
	});

	return block;
}

// (105:6) {#each lines as {level, message, timestamp}}
function create_each_block(ctx) {
	let p;
	let t;
	let p_hidden_value;

	function select_block_type(ctx, dirty) {
		if (typeof /*message*/ ctx[11] === "string") return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			p = internal.element("p");
			if_block.c();
			t = internal.space();
			p.hidden = p_hidden_value = /*filters*/ ctx[5].length && !/*filters*/ ctx[5].includes(/*level*/ ctx[10]);
			internal.attr_dev(p, "class", "svelte-n6w8gh");
			internal.add_location(p, file, 105, 8, 2350);
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, p, anchor);
			if_block.m(p, null);
			internal.append_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(p, t);
				}
			}

			if (dirty & /*filters, lines*/ 33 && p_hidden_value !== (p_hidden_value = /*filters*/ ctx[5].length && !/*filters*/ ctx[5].includes(/*level*/ ctx[10]))) {
				internal.prop_dev(p, "hidden", p_hidden_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(p);
			if_block.d();
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(105:6) {#each lines as {level, message, timestamp}}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div1;
	let div0;
	let button0;
	let t1;
	let button1;
	let t3;
	let button2;
	let t5;
	let button3;
	let t7;
	let div3;
	let div2;
	let mounted;
	let dispose;
	let each_value = /*lines*/ ctx[0];
	internal.validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div1 = internal.element("div");
			div0 = internal.element("div");
			button0 = internal.element("button");
			button0.textContent = "Log";
			t1 = internal.space();
			button1 = internal.element("button");
			button1.textContent = "Info";
			t3 = internal.space();
			button2 = internal.element("button");
			button2.textContent = "Warning";
			t5 = internal.space();
			button3 = internal.element("button");
			button3.textContent = "Error";
			t7 = internal.space();
			div3 = internal.element("div");
			div2 = internal.element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			internal.attr_dev(button0, "class", "btn");
			internal.add_location(button0, file, 95, 4, 1925);
			internal.attr_dev(button1, "class", "btn");
			internal.add_location(button1, file, 96, 4, 1987);
			internal.attr_dev(button2, "class", "btn");
			internal.add_location(button2, file, 97, 4, 2050);
			internal.attr_dev(button3, "class", "btn");
			internal.add_location(button3, file, 98, 4, 2116);
			internal.attr_dev(div0, "class", "btn-group");
			internal.add_location(div0, file, 94, 2, 1897);
			internal.attr_dev(div1, "class", "block");
			internal.add_location(div1, file, 93, 0, 1875);
			internal.attr_dev(div2, "class", "console-lines svelte-n6w8gh");
			internal.attr_dev(div2, "tabindex", "-1");
			internal.add_location(div2, file, 103, 4, 2249);
			internal.attr_dev(div3, "class", "panel-body scrollable svelte-n6w8gh");
			internal.add_location(div3, file, 102, 0, 2193);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, div1, anchor);
			internal.append_dev(div1, div0);
			internal.append_dev(div0, button0);
			internal.append_dev(div0, t1);
			internal.append_dev(div0, button1);
			internal.append_dev(div0, t3);
			internal.append_dev(div0, button2);
			internal.append_dev(div0, t5);
			internal.append_dev(div0, button3);
			internal.insert_dev(target, t7, anchor);
			internal.insert_dev(target, div3, anchor);
			internal.append_dev(div3, div2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div2, null);
			}

			/*div3_binding*/ ctx[8](div3);

			if (!mounted) {
				dispose = [
					internal.listen_dev(button0, "click", /*filterHandler*/ ctx[7], false, false, false),
					internal.listen_dev(button1, "click", /*filterHandler*/ ctx[7], false, false, false),
					internal.listen_dev(button2, "click", /*filterHandler*/ ctx[7], false, false, false),
					internal.listen_dev(button3, "click", /*filterHandler*/ ctx[7], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*filters, lines, wordWrap, handleOverflow, coloredBadges, mapLevel, scrollToTop, showTimestamp*/ 125) {
				each_value = /*lines*/ ctx[0];
				internal.validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div2, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: internal.noop,
		o: internal.noop,
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(div1);
			if (detaching) internal.detach_dev(t7);
			if (detaching) internal.detach_dev(div3);
			internal.destroy_each(each_blocks, detaching);
			/*div3_binding*/ ctx[8](null);
			mounted = false;
			internal.run_all(dispose);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	internal.validate_slots("Console", slots, []);
	let lines;

	const unsubscribe = store.subscribe(state => {
		switch (state.action) {
			case "log":
				$$invalidate(0, lines = [...state.lines]);
				break;
			case "clear":
				$$invalidate(0, lines = []);
				break;
		}

		return lines;
	});

	let div;

	svelte.afterUpdate(() => {
		div.scrollTo({
			left: 0,
			top: div.scrollHeight,
			behaviour: "smooth"
		});
	});

	const scrollToTop = () => {
		div.scrollTo({ top: 0, left: 0, behaviour: "smooth" });
	};

	let wordWrap;

	atom.config.observe("console.wordWrap", newValue => {
		$$invalidate(2, wordWrap = newValue);
	});

	let showTimestamp;

	atom.config.observe("console.showTimestamp", newValue => {
		$$invalidate(3, showTimestamp = newValue);
	});

	let coloredBadges;

	atom.config.observe("console.coloredBadges", newValue => {
		$$invalidate(4, coloredBadges = newValue ? "badge" : "text");
	});

	let filters = [];

	const filterHandler = event => {
		event.target.classList.toggle("selected");
		const filter = event.target.innerText.toLowerCase();

		store.update(state => {
			console.log("filters before", state.filters);

			if (state.filters.includes(filter)) {
				const index = state.filters.indexOf(filter);
				state.filters.splice(index, 1);
			} else {
				state.filters.push(filter);
			}

			$$invalidate(5, filters = state.filters);
			console.log("filters after", state.filters);
			return state;
		});
	};

	svelte.onMount(() => initStatusBarHeight());
	svelte.onDestroy(unsubscribe);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Console> was created with unknown prop '${key}'`);
	});

	function div3_binding($$value) {
		internal.binding_callbacks[$$value ? "unshift" : "push"](() => {
			div = $$value;
			$$invalidate(1, div);
		});
	}

	$$self.$capture_state = () => ({
		afterUpdate: svelte.afterUpdate,
		onDestroy: svelte.onDestroy,
		onMount: svelte.onMount,
		store,
		handleOverflow,
		initStatusBarHeight,
		mapLevel,
		lines,
		unsubscribe,
		div,
		scrollToTop,
		wordWrap,
		showTimestamp,
		coloredBadges,
		filters,
		filterHandler
	});

	$$self.$inject_state = $$props => {
		if ("lines" in $$props) $$invalidate(0, lines = $$props.lines);
		if ("div" in $$props) $$invalidate(1, div = $$props.div);
		if ("wordWrap" in $$props) $$invalidate(2, wordWrap = $$props.wordWrap);
		if ("showTimestamp" in $$props) $$invalidate(3, showTimestamp = $$props.showTimestamp);
		if ("coloredBadges" in $$props) $$invalidate(4, coloredBadges = $$props.coloredBadges);
		if ("filters" in $$props) $$invalidate(5, filters = $$props.filters);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		lines,
		div,
		wordWrap,
		showTimestamp,
		coloredBadges,
		filters,
		scrollToTop,
		filterHandler,
		div3_binding
	];
}

class Console extends internal.SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-n6w8gh-style")) add_css();
		internal.init(this, options, instance, create_fragment, internal.safe_not_equal, {});

		internal.dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Console",
			options,
			id: create_fragment.name
		});
	}
}

class ConsoleView {
  destroy() {
    if (this.disposables !== null) {
      this.disposables.dispose();
    }
  }

  getElement() {
    const element = document.createElement('console');
    new Console({
      target: element
    });
    return element;
  }

  getTitle() {
    return 'Console';
  }

  getPath() {
    return 'panel';
  }

  getURI() {
    return `atom://console/${this.getPath()}`;
  }

  getDefaultLocation() {
    return getConfig('panelLocation');
  }

  show() {
    atom.workspace.open(this, {
      activatePane: false
    });
    showDock();
  }

  hide() {
    hideDock();
  }

  toggle() {
    atom.workspace.toggle(this);
  }

  log(message, level) {
    console.log({
      level,
      message
    });
    store.update(state => {
      state.lines = [...(state.lines || []), {
        level,
        message,
        timestamp: getTimestamp()
      }];
      state.action = 'log';
      return state;
    });
  }

  clear() {
    console.log('Clearing console');
    store.update(state => {
      state.action = 'clear';
      state.lines = [];
      return state;
    });
  }

}

var configSchema = {
  showTimestamp: {
    description: 'Displays a timestamp next to the output',
    type: 'boolean',
    default: true,
    order: 1
  },
  coloredBadges: {
    description: 'Colors background of the timestamp badge',
    type: 'boolean',
    default: false,
    order: 2
  },
  wordWrap: {
    description: 'Wrap words if the line length exceeds the panel width',
    type: 'boolean',
    default: true,
    order: 3
  },
  panelLocation: {
    title: 'Panel Location',
    description: 'Specifies the panel location. The change will only take effect on the next launch.',
    type: 'string',
    order: 4,
    enum: [{
      value: 'bottom',
      description: 'bottom'
    }, {
      value: 'left',
      description: 'left'
    }, {
      value: 'right',
      description: 'right'
    }],
    default: 'bottom'
  }
};

var console$1 = {
  config: configSchema,
  consoleView: null,
  subscriptions: null,

  activate() {
    this.consoleView = new ConsoleView();
    this.consoleManager = new ConsoleManager(this.consoleView); // Events subscribed to in atom's system can be easily cleaned up with a CompositeDisposable

    this.subscriptions = new atom$1.CompositeDisposable(); // Register command that toggles this view

    this.subscriptions.add(atom.commands.add('atom-workspace', {
      'console:show': () => this.consoleManager.show()
    }));
    this.subscriptions.add(atom.commands.add('atom-workspace', {
      'console:hide': () => this.consoleManager.hide()
    }));
    this.subscriptions.add(atom.commands.add('atom-workspace', {
      'console:toggle': () => this.consoleManager.toggle()
    }));
    this.subscriptions.add(atom.commands.add('atom-workspace', {
      'console:clear': () => this.consoleManager.clear()
    }));
    window.cp = this.consoleManager;

    if (atom.inDevMode()) {
      atom.commands.add('atom-workspace', {
        'console:log': () => this.consoleManager.raw({
          msg: 'Hello World'
        })
      });
    }
  },

  deactivate() {
    console.log('Deactivating');
    this.subscriptions.dispose();
    this.consoleView.destroy();
  },

  provideConsolePanel() {
    return this.consoleManager;
  }

};

module.exports = console$1;
//# sourceMappingURL=console.js.map
